From 8f9c7201ff264611aadb7c5a74a6bded52a0e84a Mon Sep 17 00:00:00 2001
From: RaoJiaYi <raojiayi@huawei.com>
Date: Tue, 21 Feb 2023 16:00:03 +0800
Subject: [PATCH] rjy

---
 configs/rec/rec_r34_vd_tps_bilstm_att.yml     |  8 ++---
 ppocr/modeling/transforms/tps.py              |  6 +++-
 .../transforms/tps_spatial_transformer.py     | 32 ++++++++++++++++++-
 3 files changed, 40 insertions(+), 6 deletions(-)

diff --git a/configs/rec/rec_r34_vd_tps_bilstm_att.yml b/configs/rec/rec_r34_vd_tps_bilstm_att.yml
index 8919aae7..a3331e03 100644
--- a/configs/rec/rec_r34_vd_tps_bilstm_att.yml
+++ b/configs/rec/rec_r34_vd_tps_bilstm_att.yml
@@ -1,5 +1,5 @@
 Global:
-  use_gpu: True
+  use_gpu: False
   epoch_num: 400
   log_smooth_window: 20
   print_batch_step: 10
@@ -83,7 +83,7 @@ Train:
 Eval:
   dataset:
     name: LMDBDataSet
-    data_dir: ./train_data/data_lmdb_release/validation/
+    data_dir: ./train_data/data_lmdb_release/evaluation/
     transforms:
       - DecodeImage: # load image
           img_mode: BGR
@@ -96,5 +96,5 @@ Eval:
   loader:
     shuffle: False
     drop_last: False
-    batch_size_per_card: 256
-    num_workers: 8
+    batch_size_per_card: 1
+    num_workers: 1
diff --git a/ppocr/modeling/transforms/tps.py b/ppocr/modeling/transforms/tps.py
index 9bdab0f8..f1bcf82a 100644
--- a/ppocr/modeling/transforms/tps.py
+++ b/ppocr/modeling/transforms/tps.py
@@ -19,11 +19,12 @@ https://github.com/clovaai/deep-text-recognition-benchmark/blob/master/modules/t
 from __future__ import absolute_import
 from __future__ import division
 from __future__ import print_function
-
+import os
 import math
 import paddle
 from paddle import nn, ParamAttr
 from paddle.nn import functional as F
+import paddle.nn as nn
 import numpy as np
 
 
@@ -233,6 +234,7 @@ class GridGenerator(nn.Layer):
 
     def build_inv_delta_C_paddle(self, C):
         """ Return inv_delta_C which is needed to calculate T """
+        '''
         F = self.F
         hat_eye = paddle.eye(F, dtype='float64')  # F x F
         hat_C = paddle.norm(
@@ -260,6 +262,8 @@ class GridGenerator(nn.Layer):
             ],
             axis=0)
         inv_delta_C = paddle.inverse(delta_C)
+        '''
+        inv_delta_C = paddle.to_tensor(np.load(os.path.join(os.getcwd(), 'inv_delta_C.npy')))
         return inv_delta_C  # F+3 x F+3
 
     def build_P_hat_paddle(self, C, P):
diff --git a/ppocr/modeling/transforms/tps_spatial_transformer.py b/ppocr/modeling/transforms/tps_spatial_transformer.py
index cb1cb10a..8dde5aa4 100644
--- a/ppocr/modeling/transforms/tps_spatial_transformer.py
+++ b/ppocr/modeling/transforms/tps_spatial_transformer.py
@@ -26,7 +26,6 @@ from paddle.nn import functional as F
 import numpy as np
 import itertools
 
-
 def grid_sample(input, grid, canvas=None):
     input.stop_gradient = False
     output = F.grid_sample(input, grid)
@@ -39,6 +38,37 @@ def grid_sample(input, grid, canvas=None):
         return padded_output
 
 
+
+def grid_sample(input, grid, canvas=None):
+    input.stop_gradient = False
+    input = paddle.transpose(input, perm=[0,1,3,2])
+    grid = paddle.transpose(grid, perm=[0,2,1,3])
+
+    input = paddle.add(input, paddle.zeros((1,3,256,64)))
+    grid = paddle.add(grid, paddle.zeros((1,100,32,2)))
+
+    input = paddle.transpose(input, perm=[0,1,3,2])
+    grid = paddle.transpose(grid, perm=[0,2,1,3])
+
+    my_pad = nn.Pad2D(padding=[1,0,0,0])
+    grid = my_pad(grid)
+    grid = paddle.transpose(grid, perm=[0,3,1,2])
+    grid = grid + input[:,:,:32,:100]
+
+    grid = paddle.transpose(grid, perm=[0,1,3,2])
+    grid = paddle.add(grid, paddle.zeros((1,3,100,32)))
+    grid = paddle.transpose(grid, perm=[0,1,3,2])
+
+
+    if canvas is None:
+        return grid
+    else:
+        input_mask = paddle.ones(shape=input.shape)
+        output_mask = F.grid_sample(input_mask, grid)
+        padded_output = output * output_mask + canvas * (1 - output_mask)
+        return padded_output
+
+
 # phi(x1, x2) = r^2 * log(r), where r = ||x1 - x2||_2
 def compute_partial_repr(input_points, control_points):
     N = input_points.shape[0]
-- 